// Code generated by a script. DO NOT EDIT.
package mikrotik

import (
	"context"
	"github.com/ddelnano/terraform-provider-mikrotik/client"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceBgpPeer() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceBgpPeerCreate,
		ReadContext:   resourceBgpPeerRead,
		UpdateContext: resourceBgpPeerUpdate,
		DeleteContext: resourceBgpPeerDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type: schema.TypeString,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"address_families": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  "ip",
			},
			"allow_as_in": {
				Type: schema.TypeInt,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"as_override": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"cisco_vpls_nlri_len_fmt": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"comment": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"default_originate": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  "never",
			},
			"disabled": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"hold_time": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  "3m",
			},
			"in_filter": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"instance": {
				Type: schema.TypeString,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"keepalive_time": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"max_prefix_limit": {
				Type: schema.TypeInt,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"max_prefix_restart_time": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"multihop": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"nexthop_choice": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  "default",
			},
			"out_filter": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"passive": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"remote_address": {
				Type: schema.TypeString,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"remote_as": {
				Type: schema.TypeInt,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"remote_port": {
				Type: schema.TypeInt,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"remove_private_as": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"route_reflect": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"tcp_md5_key": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"ttl": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  "default",
			},
			"update_source": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"use_bfd": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
		},
	}
}

func resourceBgpPeerCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	record := dataToBgpPeer(d)

	c := m.(*client.Mikrotik)

	mikrotikRecord, err := c.AddBgpPeer(record)
	if err != nil {
		return diag.FromErr(err)
	}

	return bgpPeerToData(mikrotikRecord, d)
}

func resourceBgpPeerRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)

	record, err := c.FindBgpPeer(d.Id())

	if _, ok := err.(*client.NotFound); ok {
		d.SetId("")
		return nil
	}

	return bgpPeerToData(record, d)
}

func resourceBgpPeerUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)

	currentRecord, err := c.FindBgpPeer(d.Id())
	record := dataToBgpPeer(d)
	record.ID = currentRecord.ID

	if err != nil {
		return diag.FromErr(err)
	}

	updatedRecord, err := c.UpdateBgpPeer(record)
	if err != nil {
		return diag.FromErr(err)
	}

	return bgpPeerToData(updatedRecord, d)
}

func resourceBgpPeerDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)
	id := d.Id()

	err := c.DeleteBgpPeer(id)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func dataToBgpPeer(d *schema.ResourceData) *client.BgpPeer {
	record := new(client.BgpPeer)

	record.Name = d.Get("name").(string)
	record.AddressFamilies = d.Get("address_families").(string)
	record.AllowAsIn = d.Get("allow_as_in").(int)
	record.AsOverride = d.Get("as_override").(bool)
	record.CiscoVplsNlriLenFmt = d.Get("cisco_vpls_nlri_len_fmt").(string)
	record.Comment = d.Get("comment").(string)
	record.DefaultOriginate = d.Get("default_originate").(string)
	record.Disabled = d.Get("disabled").(bool)
	record.HoldTime = d.Get("hold_time").(string)
	record.InFilter = d.Get("in_filter").(string)
	record.Instance = d.Get("instance").(string)
	record.KeepAliveTime = d.Get("keepalive_time").(string)
	record.MaxPrefixLimit = d.Get("max_prefix_limit").(int)
	record.MaxPrefixRestartTime = d.Get("max_prefix_restart_time").(string)
	record.Multihop = d.Get("multihop").(bool)
	record.NexthopChoice = d.Get("nexthop_choice").(string)
	record.OutFilter = d.Get("out_filter").(string)
	record.Passive = d.Get("passive").(bool)
	record.RemoteAddress = d.Get("remote_address").(string)
	record.RemoteAs = d.Get("remote_as").(int)
	record.RemotePort = d.Get("remote_port").(int)
	record.RemovePrivateAs = d.Get("remove_private_as").(bool)
	record.RouteReflect = d.Get("route_reflect").(bool)
	record.TCPMd5Key = d.Get("tcp_md5_key").(string)
	record.TTL = d.Get("ttl").(string)
	record.UpdateSource = d.Get("update_source").(string)
	record.UseBfd = d.Get("use_bfd").(bool)

	return record
}

func bgpPeerToData(record *client.BgpPeer, d *schema.ResourceData) diag.Diagnostics {
	values := map[string]interface{}{
		"name":                    record.Name,
		"address_families":        record.AddressFamilies,
		"allow_as_in":             record.AllowAsIn,
		"as_override":             record.AsOverride,
		"cisco_vpls_nlri_len_fmt": record.CiscoVplsNlriLenFmt,
		"comment":                 record.Comment,
		"default_originate":       record.DefaultOriginate,
		"disabled":                record.Disabled,
		"hold_time":               record.HoldTime,
		"in_filter":               record.InFilter,
		"instance":                record.Instance,
		"keepalive_time":          record.KeepAliveTime,
		"max_prefix_limit":        record.MaxPrefixLimit,
		"max_prefix_restart_time": record.MaxPrefixRestartTime,
		"multihop":                record.Multihop,
		"nexthop_choice":          record.NexthopChoice,
		"out_filter":              record.OutFilter,
		"passive":                 record.Passive,
		"remote_address":          record.RemoteAddress,
		"remote_as":               record.RemoteAs,
		"remote_port":             record.RemotePort,
		"remove_private_as":       record.RemovePrivateAs,
		"route_reflect":           record.RouteReflect,
		"tcp_md5_key":             record.TCPMd5Key,
		"ttl":                     record.TTL,
		"update_source":           record.UpdateSource,
		"use_bfd":                 record.UseBfd,
	}

	d.SetId(record.Name)

	var diags diag.Diagnostics

	for key, value := range values {
		if err := d.Set(key, value); err != nil {
			diags = append(diags, diag.Errorf("failed to set %s: %v", key, err)...)
		}
	}

	return diags
}
