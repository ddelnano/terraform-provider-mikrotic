// Code generated by a script. DO NOT EDIT.
package mikrotik

import (
	"context"
	"github.com/ddelnano/terraform-provider-mikrotik/client"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceBgpInstance() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceBgpInstanceCreate,
		ReadContext:   resourceBgpInstanceRead,
		UpdateContext: resourceBgpInstanceUpdate,
		DeleteContext: resourceBgpInstanceDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type: schema.TypeString,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"as": {
				Type: schema.TypeInt,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"client_to_client_reflection": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
				Default:  true,
			},
			"comment": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"confederation_peers": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"disabled": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"ignore_as_path_len": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"out_filter": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"redistribute_connected": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"redistribute_ospf": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"redistribute_other_bgp": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"redistribute_rip": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"redistribute_static": {
				Type: schema.TypeBool,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"router_id": {
				Type: schema.TypeString,

				Required: true,
				Optional: false,
				Computed: false,
			},
			"routing_table": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"cluster_id": {
				Type: schema.TypeString,

				Required: false,
				Optional: true,
				Computed: false,
			},
			"confederation": {
				Type: schema.TypeInt,

				Required: false,
				Optional: true,
				Computed: false,
			},
		},
	}
}

func resourceBgpInstanceCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	record := dataToBgpInstance(d)

	c := m.(*client.Mikrotik)

	mikrotikRecord, err := c.AddBgpInstance(record)
	if err != nil {
		return diag.FromErr(err)
	}

	return bgpInstanceToData(mikrotikRecord, d)
}

func resourceBgpInstanceRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)

	record, err := c.FindBgpInstance(d.Id())

	if _, ok := err.(*client.NotFound); ok {
		d.SetId("")
		return nil
	}

	return bgpInstanceToData(record, d)
}

func resourceBgpInstanceUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)

	currentRecord, err := c.FindBgpInstance(d.Id())
	record := dataToBgpInstance(d)
	record.ID = currentRecord.ID

	if err != nil {
		return diag.FromErr(err)
	}

	updatedRecord, err := c.UpdateBgpInstance(record)
	if err != nil {
		return diag.FromErr(err)
	}

	return bgpInstanceToData(updatedRecord, d)
}

func resourceBgpInstanceDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	c := m.(*client.Mikrotik)
	id := d.Id()

	err := c.DeleteBgpInstance(id)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func dataToBgpInstance(d *schema.ResourceData) *client.BgpInstance {
	record := new(client.BgpInstance)

	record.Name = d.Get("name").(string)
	record.As = d.Get("as").(int)
	record.ClientToClientReflection = d.Get("client_to_client_reflection").(bool)
	record.Comment = d.Get("comment").(string)
	record.ConfederationPeers = d.Get("confederation_peers").(string)
	record.Disabled = d.Get("disabled").(bool)
	record.IgnoreAsPathLen = d.Get("ignore_as_path_len").(bool)
	record.OutFilter = d.Get("out_filter").(string)
	record.RedistributeConnected = d.Get("redistribute_connected").(bool)
	record.RedistributeOspf = d.Get("redistribute_ospf").(bool)
	record.RedistributeOtherBgp = d.Get("redistribute_other_bgp").(bool)
	record.RedistributeRip = d.Get("redistribute_rip").(bool)
	record.RedistributeStatic = d.Get("redistribute_static").(bool)
	record.RouterID = d.Get("router_id").(string)
	record.RoutingTable = d.Get("routing_table").(string)
	record.ClusterID = d.Get("cluster_id").(string)
	record.Confederation = d.Get("confederation").(int)

	return record
}

func bgpInstanceToData(record *client.BgpInstance, d *schema.ResourceData) diag.Diagnostics {
	values := map[string]interface{}{
		"name":                        record.Name,
		"as":                          record.As,
		"client_to_client_reflection": record.ClientToClientReflection,
		"comment":                     record.Comment,
		"confederation_peers":         record.ConfederationPeers,
		"disabled":                    record.Disabled,
		"ignore_as_path_len":          record.IgnoreAsPathLen,
		"out_filter":                  record.OutFilter,
		"redistribute_connected":      record.RedistributeConnected,
		"redistribute_ospf":           record.RedistributeOspf,
		"redistribute_other_bgp":      record.RedistributeOtherBgp,
		"redistribute_rip":            record.RedistributeRip,
		"redistribute_static":         record.RedistributeStatic,
		"router_id":                   record.RouterID,
		"routing_table":               record.RoutingTable,
		"cluster_id":                  record.ClusterID,
		"confederation":               record.Confederation,
	}

	d.SetId(record.Name)

	var diags diag.Diagnostics

	for key, value := range values {
		if err := d.Set(key, value); err != nil {
			diags = append(diags, diag.Errorf("failed to set %s: %v", key, err)...)
		}
	}

	return diags
}
