package codegen

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const (
	generatedNotice = "// Code generated by a script. DO NOT EDIT."

	resourceDefinitionTemplate = `
		package {{ .Package }}

		import (
			{{ range $import := .Imports -}}
				"{{ $import }}"
			{{ end }}
		)

		func resource{{ .ResourceName }}() *schema.Resource {
			return &schema.Resource{
				CreateContext: resource{{ .ResourceName }}Create,
				ReadContext:   resource{{ .ResourceName }}Read,
				UpdateContext: resource{{ .ResourceName }}Update,
				DeleteContext: resource{{ .ResourceName }}Delete,
				Importer: &schema.ResourceImporter{
					StateContext: schema.ImportStatePassthroughContext,
				},

				Schema: map[string]*schema.Schema{
					{{ range .TerraformFields -}}
					"{{ .Name }}": {
						Type:     schema.{{ .Type }},
						{{ if eq (printf "%s" .Type) "TypeList" -}}
						Elem: &schema.Schema{
							Type: schema.{{ .ElemType }},
						},
						{{- end }}
						Required: {{ .Required }},
						Optional: {{ .Optional }},
						Computed: {{ .Computed }},
						{{ if ne .DefaultValue "" -}}
						Default: {{ .DefaultValue }},
						{{- end }}
					},
					{{ end }}
				},
			}
		}

	func resource{{ .ResourceName }}Create(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		record := dataTo{{ .ResourceName }}(d)

		c := m.(*client.Mikrotik)

		mikrotikRecord, err := c.Add{{ .ResourceName }}(record)
		if err != nil {
			return diag.FromErr(err)
		}

		return {{ .ResourceName | firstLower }}ToData(mikrotikRecord, d)
	}

	func resource{{ .ResourceName }}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		c := m.(*client.Mikrotik)

		record, err := c.Find{{ .ResourceName }}(d.Id())

		if _, ok := err.(*client.NotFound); ok {
			d.SetId("")
			return nil
		}

		return {{ .ResourceName | firstLower }}ToData(record, d)
	}

	func resource{{ .ResourceName }}Update(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		c := m.(*client.Mikrotik)

		currentRecord, err := c.Find{{ .ResourceName }}(d.Id())
		record := dataTo{{ .ResourceName }}(d)
		record.{{ .MikrotikIDField }} = currentRecord.{{ .MikrotikIDField }}

		if err != nil {
			return diag.FromErr(err)
		}

		updatedRecord, err := c.Update{{ .ResourceName }}(record)
		if err != nil {
			return diag.FromErr(err)
		}

		return {{ .ResourceName | firstLower }}ToData(updatedRecord, d)
	}

	func resource{{ .ResourceName }}Delete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		c := m.(*client.Mikrotik)
		id := d.Id()

		{{ if .DeleteField -}}
		if record, err := c.Find{{ .ResourceName }}(id); err != nil {
			return diag.FromErr(err)
		} else {
			id = record.{{ .DeleteField }}
		}
		{{ end -}}

		err := c.Delete{{ .ResourceName }}(id)
		if err != nil {
			return diag.FromErr(err)
		}

		return nil
	}

	func dataTo{{ .ResourceName }}(d *schema.ResourceData) *client.{{ .ResourceName }} {
		record := new(client.{{ .ResourceName }})

		{{ range .Fields -}}
		record.{{ .OriginalName }} = d.Get("{{ .Name }}").({{ .Type }})
		{{ end }}
		return record
	}

	func {{ .ResourceName | firstLower }}ToData(record *client.{{ .ResourceName }}, d *schema.ResourceData) diag.Diagnostics {
		values := map[string]interface{}{
			{{ range .Fields -}}
			"{{ .Name }}":    record.{{ .OriginalName }},
			{{ end }}
		}

		d.SetId(record.{{ .TerraformIDField }})

		var diags diag.Diagnostics

		for key, value := range values {
			if err := d.Set(key, value); err != nil {
				diags = append(diags, diag.Errorf("failed to set %s: %v", key, err)...)
			}
		}

		return diags
	}

	`
)

var (
	stringTypeToTerraformType = map[string]schema.ValueType{
		"slice":  schema.TypeList,
		"string": schema.TypeString,
		"bool":   schema.TypeBool,
		"int":    schema.TypeInt,
	}

	defaultImports = []string{
		"context",
		"github.com/ddelnano/terraform-provider-mikrotik/client",
		"github.com/hashicorp/terraform-plugin-sdk/v2/diag",
		"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema",
	}
)

type (
	// SourceWriteHookFunc defines a hook func to mutate source before writing to destination
	SourceWriteHookFunc func([]byte) ([]byte, error)

	sourceWriter interface {
		Write([]byte) (int, error)
	}

	terraformField struct {
		Name         string
		Type         schema.ValueType
		ElemType     schema.ValueType
		DefaultValue string
		Required     bool
		Optional     bool
		Computed     bool
	}

	templateData struct {
		Package            string
		Imports            []string
		ResourceName       string
		TerraformFields    []terraformField
		Fields             []Field
		TerraformIDField   string
		MikrotikIDField    string
		DeleteField        string
		DeleteByMikrotikID bool
	}
)

// GenerateResource generates Terraform resource and writes it to specified output
func GenerateResource(s *Struct, w io.Writer, beforeWriteHooks ...SourceWriteHookFunc) error {
	var result []byte
	var buf bytes.Buffer
	var err error

	if err := generateResource(&buf, *s); err != nil {
		return err
	}
	result = buf.Bytes()
	for _, h := range beforeWriteHooks {
		result, err = h(result)
		if err != nil {
			return err
		}
	}

	_, err = w.Write(result)
	if err != nil {
		return err
	}

	return nil
}

func generateResource(w sourceWriter, s Struct) error {
	if err := writeWrapper(w, []byte(generatedNotice)); err != nil {
		return err
	}
	fields, err := convertToTerraformDefinition(s.Fields)
	if err != nil {
		return err
	}

	t := template.New("resource")
	t.Funcs(template.FuncMap{
		"lowercase": strings.ToLower,
		"firstLower": func(s string) string {
			if len(s) < 1 {
				return s
			}
			if len(s) == 1 {
				return strings.ToLower(s)
			}

			return strings.ToLower(s[:1]) + s[1:]
		},
	})
	if _, err := t.Parse(resourceDefinitionTemplate); err != nil {
		return err
	}

	if err := t.Execute(w,
		templateData{
			ResourceName:     s.Name,
			TerraformFields:  fields,
			Fields:           s.Fields,
			Package:          "mikrotik",
			TerraformIDField: s.TerraformIDField,
			MikrotikIDField:  s.MikrotikIDField,
			DeleteField:      s.DeleteField,
			Imports:          defaultImports,
		}); err != nil {
		return err
	}

	return nil
}

func convertToTerraformDefinition(fields []Field) ([]terraformField, error) {
	result := []terraformField{}

	for _, f := range fields {
		fieldType := typeToTerraformType(f.Type)
		if fieldType == schema.TypeInvalid {
			return []terraformField{}, fmt.Errorf("unsupported field type: %s", f.Type)
		}
		defaultValue := f.DefaultValueStr
		if fieldType == schema.TypeString && defaultValue != "" {
			defaultValue = `"` + defaultValue + `"`
		}
		elemType := schema.TypeInvalid
		// currently, only list supports element typing
		if fieldType == schema.TypeList {
			elemType = typeToTerraformType(f.ElemType)
			if elemType == schema.TypeInvalid {
				return []terraformField{}, fmt.Errorf("unsupported field type: %s", f.ElemType)
			}
		}
		result = append(result, terraformField{
			Name:         strings.ToLower(f.Name),
			Type:         fieldType,
			ElemType:     elemType,
			DefaultValue: defaultValue,
			Required:     f.Required,
			Optional:     f.Optional,
			Computed:     f.Computed,
		})
	}

	return result, nil
}

func typeToTerraformType(typ string) schema.ValueType {
	if t, ok := stringTypeToTerraformType[typ]; ok {
		return t
	}

	return schema.TypeInvalid
}

func writeWrapper(w sourceWriter, data []byte) error {
	_, err := w.Write(data)

	return err
}
