package codegen

import (
	"bytes"
	"io"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

const (
	generatedNotice = "// Code generated by a script. DO NOT EDIT."

	resourceDefinitionTemplate = `
		package {{ .Package }}

		import (
			{{ range $import := .Imports -}}
				"{{ $import }}"
			{{ end }}
		)

		func resource{{ .ResourceName }}() *schema.Resource {
			return &schema.Resource{
				CreateContext: resource{{ .ResourceName }}Create,
				ReadContext:   resource{{ .ResourceName }}Read,
				UpdateContext: resource{{ .ResourceName }}Update,
				DeleteContext: resource{{ .ResourceName }}Delete,
				Importer: &schema.ResourceImporter{
					StateContext: schema.ImportStatePassthroughContext,
				},

				Schema: map[string]*schema.Schema{
					{{ range .TerraformFields -}}
					"{{ .Name }}": {
						Type:     schema.{{ .Type }},
						Required: {{ .Required }},
						Optional: {{ .Optional }},
						Computed: {{ .Computed }},
					},
					{{ end }}
				},
			}
		}

	func resource{{ .ResourceName }}Create(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		record := dataTo{{ .ResourceName }}(d)

		c := m.(*client.Mikrotik)

		mikrotikRecord, err := c.Add{{ .ResourceName }}(record)
		if err != nil {
			return diag.FromErr(err)
		}

		return {{ .ResourceName | firstLower }}ToData(mikrotikRecord, d)
	}

	func dataTo{{ .ResourceName }}(d *schema.ResourceData) *client.{{ .ResourceName }} {
		record := new(client.{{ .ResourceName }})

		{{ range .Fields -}}
		record.{{ .OriginalName }} = d.Get("{{ .Name }}").({{ .Type }})
		{{ end }}
		return record
	}

	func {{ .ResourceName | firstLower }}ToData(record *client.{{ .ResourceName }}, d *schema.ResourceData) diag.Diagnostics {
		values := map[string]interface{}{
			{{ range .Fields -}}
			"{{ .Name }}":    record.{{ .OriginalName }},
			{{ end }}
		}

		d.SetId(record.{{ .IDFieldName }})

		var diags diag.Diagnostics

		for key, value := range values {
			if err := d.Set(key, value); err != nil {
				diags = append(diags, diag.Errorf("failed to set %s: %v", key, err)...)
			}
		}

		return diags
	}

	func resource{{ .ResourceName }}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		c := m.(*client.Mikrotik)

		record, err := c.Find{{ .ResourceName }}(d.Id())

		if _, ok := err.(*client.NotFound); ok {
			d.SetId("")
			return nil
		}

		return {{ .ResourceName | firstLower }}ToData(record, d)
	}

	func resource{{ .ResourceName }}Update(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		c := m.(*client.Mikrotik)

		currentRecord, err := c.Find{{ .ResourceName }}(d.Id())
		record := dataTo{{ .ResourceName }}(d)
		record.Id = currentRecord.Id

		if err != nil {
			return diag.FromErr(err)
		}

		updatedRecord, err := c.Update{{ .ResourceName }}(record)
		if err != nil {
			return diag.FromErr(err)
		}

		return {{ .ResourceName | firstLower }}ToData(updatedRecord, d)
	}

	func resource{{ .ResourceName }}Delete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
		name := d.Id()

		c := m.(*client.Mikrotik)

		record, err := c.Find{{ .ResourceName }}(name)

		if err != nil {
			return diag.FromErr(err)
		}
		err = c.Delete{{ .ResourceName }}(record.{{ .IDFieldName }})

		if err != nil {
			return diag.FromErr(err)
		}
		d.SetId("")
		return nil
	}

	`
)

var (
	stringTypeToTerraformType = map[string]schema.ValueType{
		"string": schema.TypeString,
		"bool":   schema.TypeBool,
		"int":    schema.TypeInt,
	}

	defaultImports = []string{
		"context",
		"github.com/ddelnano/terraform-provider-mikrotik/client",
		"github.com/hashicorp/terraform-plugin-sdk/v2/diag",
		"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema",
	}
)

type (
	// SourceWriteHookFunc defines a hook func to mutate source before writing to destination
	SourceWriteHookFunc func([]byte) ([]byte, error)

	sourceWriter interface {
		Write([]byte) (int, error)
	}

	terraformField struct {
		Name     string
		Type     schema.ValueType
		Required bool
		Optional bool
		Computed bool
	}

	templateData struct {
		Package         string
		Imports         []string
		ResourceName    string
		TerraformFields []terraformField
		Fields          []Field
		IDFieldName     string
	}
)

// GenerateResource generates Terraform resource and writes it to specified output
func GenerateResource(s *Struct, w io.Writer, beforeWriteHooks ...SourceWriteHookFunc) error {
	var result []byte
	var buf bytes.Buffer
	var err error

	if err := generateResource(&buf, *s); err != nil {
		return err
	}
	result = buf.Bytes()
	for _, h := range beforeWriteHooks {
		result, err = h(result)
		if err != nil {
			return err
		}
	}

	_, err = w.Write(result)
	if err != nil {
		return err
	}

	return nil
}

func generateResource(w sourceWriter, s Struct) error {
	if err := writeWrapper(w, []byte(generatedNotice)); err != nil {
		return err
	}
	fields := convertToTerraformDefinition(s.Fields)
	t := template.New("resource")
	t.Funcs(template.FuncMap{
		"lowercase": strings.ToLower,
		"firstLower": func(s string) string {
			if len(s) < 1 {
				return s
			}
			if len(s) == 1 {
				return strings.ToLower(s)
			}

			return strings.ToLower(s[:1]) + s[1:]
		},
	})
	if _, err := t.Parse(resourceDefinitionTemplate); err != nil {
		return err
	}

	if err := t.Execute(w,
		templateData{
			ResourceName:    s.Name,
			TerraformFields: fields,
			Fields:          s.Fields,
			Package:         "mikrotik",
			IDFieldName:     s.IDFieldName,
			Imports:         defaultImports,
		}); err != nil {
		return err
	}

	return nil
}

func convertToTerraformDefinition(fields []Field) []terraformField {
	result := []terraformField{}

	for _, f := range fields {
		result = append(result, terraformField{
			Name:     strings.ToLower(f.Name),
			Type:     typeToTerraformType(f.Type),
			Required: f.Required,
			Optional: f.Optional,
			Computed: f.Computed,
		})
	}

	return result
}

func typeToTerraformType(typ string) schema.ValueType {
	if t, ok := stringTypeToTerraformType[typ]; ok {
		return t
	}

	return schema.TypeInvalid
}

func writeWrapper(w sourceWriter, data []byte) error {
	_, err := w.Write(data)

	return err
}
